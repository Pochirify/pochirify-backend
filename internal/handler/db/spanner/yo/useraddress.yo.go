// Code generated by yo. DO NOT EDIT.
// Package yo contains the types.
package yo

import (
	"context"
	"fmt"
	"time"

	"cloud.google.com/go/spanner"
	"google.golang.org/grpc/codes"
)

// UserAddress represents a row from 'UserAddresses'.
type UserAddress struct {
	ID            string             `spanner:"ID" json:"ID"`                       // ID
	UserID        string             `spanner:"UserID" json:"UserID"`               // UserID
	EmailAddress  string             `spanner:"EmailAddress" json:"EmailAddress"`   // EmailAddress
	ZipCode       int64              `spanner:"ZipCode" json:"ZipCode"`             // ZipCode
	Prefecture    string             `spanner:"Prefecture" json:"Prefecture"`       // Prefecture
	City          string             `spanner:"City" json:"City"`                   // City
	StreetAddress string             `spanner:"StreetAddress" json:"StreetAddress"` // StreetAddress
	Building      spanner.NullString `spanner:"Building" json:"Building"`           // Building
	LastName      string             `spanner:"LastName" json:"LastName"`           // LastName
	FirstName     string             `spanner:"FirstName" json:"FirstName"`         // FirstName
	CreateTime    time.Time          `spanner:"CreateTime" json:"CreateTime"`       // CreateTime
	UpdateTime    time.Time          `spanner:"UpdateTime" json:"UpdateTime"`       // UpdateTime
}

func UserAddressPrimaryKeys() []string {
	return []string{
		"ID",
	}
}

func UserAddressColumns() []string {
	return []string{
		"ID",
		"UserID",
		"EmailAddress",
		"ZipCode",
		"Prefecture",
		"City",
		"StreetAddress",
		"Building",
		"LastName",
		"FirstName",
		"CreateTime",
		"UpdateTime",
	}
}

func UserAddressWritableColumns() []string {
	return []string{
		"ID",
		"UserID",
		"EmailAddress",
		"ZipCode",
		"Prefecture",
		"City",
		"StreetAddress",
		"Building",
		"LastName",
		"FirstName",
		"CreateTime",
		"UpdateTime",
	}
}

func (ua *UserAddress) columnsToPtrs(cols []string, customPtrs map[string]interface{}) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		if val, ok := customPtrs[col]; ok {
			ret = append(ret, val)
			continue
		}

		switch col {
		case "ID":
			ret = append(ret, &ua.ID)
		case "UserID":
			ret = append(ret, &ua.UserID)
		case "EmailAddress":
			ret = append(ret, &ua.EmailAddress)
		case "ZipCode":
			ret = append(ret, &ua.ZipCode)
		case "Prefecture":
			ret = append(ret, &ua.Prefecture)
		case "City":
			ret = append(ret, &ua.City)
		case "StreetAddress":
			ret = append(ret, &ua.StreetAddress)
		case "Building":
			ret = append(ret, &ua.Building)
		case "LastName":
			ret = append(ret, &ua.LastName)
		case "FirstName":
			ret = append(ret, &ua.FirstName)
		case "CreateTime":
			ret = append(ret, &ua.CreateTime)
		case "UpdateTime":
			ret = append(ret, &ua.UpdateTime)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}
	return ret, nil
}

func (ua *UserAddress) columnsToValues(cols []string) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		switch col {
		case "ID":
			ret = append(ret, ua.ID)
		case "UserID":
			ret = append(ret, ua.UserID)
		case "EmailAddress":
			ret = append(ret, ua.EmailAddress)
		case "ZipCode":
			ret = append(ret, ua.ZipCode)
		case "Prefecture":
			ret = append(ret, ua.Prefecture)
		case "City":
			ret = append(ret, ua.City)
		case "StreetAddress":
			ret = append(ret, ua.StreetAddress)
		case "Building":
			ret = append(ret, ua.Building)
		case "LastName":
			ret = append(ret, ua.LastName)
		case "FirstName":
			ret = append(ret, ua.FirstName)
		case "CreateTime":
			ret = append(ret, ua.CreateTime)
		case "UpdateTime":
			ret = append(ret, ua.UpdateTime)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}

	return ret, nil
}

// newUserAddress_Decoder returns a decoder which reads a row from *spanner.Row
// into UserAddress. The decoder is not goroutine-safe. Don't use it concurrently.
func newUserAddress_Decoder(cols []string) func(*spanner.Row) (*UserAddress, error) {
	customPtrs := map[string]interface{}{}

	return func(row *spanner.Row) (*UserAddress, error) {
		var ua UserAddress
		ptrs, err := ua.columnsToPtrs(cols, customPtrs)
		if err != nil {
			return nil, err
		}

		if err := row.Columns(ptrs...); err != nil {
			return nil, err
		}

		return &ua, nil
	}
}

// Insert returns a Mutation to insert a row into a table. If the row already
// exists, the write or transaction fails.
func (ua *UserAddress) Insert(ctx context.Context) *spanner.Mutation {
	values, _ := ua.columnsToValues(UserAddressWritableColumns())
	return spanner.Insert("UserAddresses", UserAddressWritableColumns(), values)
}

// Update returns a Mutation to update a row in a table. If the row does not
// already exist, the write or transaction fails.
func (ua *UserAddress) Update(ctx context.Context) *spanner.Mutation {
	values, _ := ua.columnsToValues(UserAddressWritableColumns())
	return spanner.Update("UserAddresses", UserAddressWritableColumns(), values)
}

// InsertOrUpdate returns a Mutation to insert a row into a table. If the row
// already exists, it updates it instead. Any column values not explicitly
// written are preserved.
func (ua *UserAddress) InsertOrUpdate(ctx context.Context) *spanner.Mutation {
	values, _ := ua.columnsToValues(UserAddressWritableColumns())
	return spanner.InsertOrUpdate("UserAddresses", UserAddressWritableColumns(), values)
}

// UpdateColumns returns a Mutation to update specified columns of a row in a table.
func (ua *UserAddress) UpdateColumns(ctx context.Context, cols ...string) (*spanner.Mutation, error) {
	// add primary keys to columns to update by primary keys
	colsWithPKeys := append(cols, UserAddressPrimaryKeys()...)

	values, err := ua.columnsToValues(colsWithPKeys)
	if err != nil {
		return nil, newErrorWithCode(codes.InvalidArgument, "UserAddress.UpdateColumns", "UserAddresses", err)
	}

	return spanner.Update("UserAddresses", colsWithPKeys, values), nil
}

// FindUserAddress gets a UserAddress by primary key
func FindUserAddress(ctx context.Context, db YORODB, id string) (*UserAddress, error) {
	key := spanner.Key{id}
	row, err := db.ReadRow(ctx, "UserAddresses", key, UserAddressColumns())
	if err != nil {
		return nil, newError("FindUserAddress", "UserAddresses", err)
	}

	decoder := newUserAddress_Decoder(UserAddressColumns())
	ua, err := decoder(row)
	if err != nil {
		return nil, newErrorWithCode(codes.Internal, "FindUserAddress", "UserAddresses", err)
	}

	return ua, nil
}

// ReadUserAddress retrieves multiples rows from UserAddress by KeySet as a slice.
func ReadUserAddress(ctx context.Context, db YORODB, keys spanner.KeySet) ([]*UserAddress, error) {
	var res []*UserAddress

	decoder := newUserAddress_Decoder(UserAddressColumns())

	rows := db.Read(ctx, "UserAddresses", keys, UserAddressColumns())
	err := rows.Do(func(row *spanner.Row) error {
		ua, err := decoder(row)
		if err != nil {
			return err
		}
		res = append(res, ua)

		return nil
	})
	if err != nil {
		return nil, newErrorWithCode(codes.Internal, "ReadUserAddress", "UserAddresses", err)
	}

	return res, nil
}

// Delete deletes the UserAddress from the database.
func (ua *UserAddress) Delete(ctx context.Context) *spanner.Mutation {
	values, _ := ua.columnsToValues(UserAddressPrimaryKeys())
	return spanner.Delete("UserAddresses", spanner.Key(values))
}
